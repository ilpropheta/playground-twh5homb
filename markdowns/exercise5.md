# A functional touch

Post-modern C++ programmers master more than one paradigm and, without a doubt, **functional paradigm** is one.

We cannot really cover functional programming in C++, it would need more than a workshop! However, we could introduce a few interesting concepts and try them out.

## Lambdas, lambdas everywhere

![Lambdas, lambdas everywhere](lambdas.png)

C++11 introduced **lambda expressions** (often called **lambdas**) that are, basically, **nested anonymous functions**:

* nested because we generally create them inside another function,
* anonymous because their type and name is automatically generated by the compiler.

Typically, lambdas are used to encapsulate a few lines of code that are passed to algorithms or asynchronous methods:

```cpp
vector<int> v = {10, 20, 30, 41, 50, 67};
auto firstOdd = std::find(begin(v), end(v), [](int i) { return i%2 == 1; });
```

This expression `[](int i) { return i%2 == 1; }` generates a lambda.

C++ lambdas come with some details to master. I'll show you the most important ones and leave the others to further readings.

### What's a lambda, in short

Basically, a lambda will result in generating a **callable object** (or *functor*, in the C++ slang).

For this lambda:

```cpp
[](int i) { return i%2 == 1; }
```

the compiler could generate something very close to:

```cpp
struct lambda12384950_t
{
    bool operator()(int i) const
    {
        return i%2 == 1;
    }
};
```

Such lambdas are **stateless** and they are automatically convertible to function pointers:

```cpp
using FunPtr = bool(*)(int);

FunPtr ptr = [](int i) { return i%2 == 1; };
```

This kind of lambdas is comparable to creating static strings:

```cpp
int main()
{
    auto someString = "this is a string";
    cout << someString;
}
```

In this case:

```cpp
[](auto i) { return i%2 == 1; }
```

The call operator is templatized:

```cpp
struct lambda12384950_t
{
    template<typename T>
    bool operator()(T i) const
    {
        return i%2 == 1;
    }
};
```

As you will learn in a moment, lambdas can *capture* variables in outer and global scopes, becoming **stateful**:

```cpp
vector<int> prices = {1,2,3};
auto isInPrices = [v](int i) { return find(begin(v), end(v), i) != end(v); };
```

The lambda above may be turned into:

```cpp
struct lambda12384950_t
{
    lambda12384950_t(const vector<int>& field)
        : _private_field_1(field)
    {}

    bool operator()(T i) const
    {
        return find(begin(_private_field_1), end(_private_field_1), i) != end(_private_field_1);
    }
    
private:
    vector<int> _private_field_1;
};
```

Clearly, this kind of lambda cannot be converted to function pointers.

### Parameter list

Just as ordinary functions, lambdas can accept input parameters:

```cpp
auto l = [](int i) { return i%2 == 1; };
```

From C++14 we can leave the compiler deduce parameters automatically (adopting templates deduction rules):

```cpp
auto l = [](auto i) { cout << i << "\n"; };
```

The parameter list is optional when the lambda is parameterless:

```cpp
auto l = [] { cout << "hello" << "\n"; };
```

### Lambda capture

A lambda can introduce new variables in its body (in C++14), and it can also access (**capture**) variables from the surrounding scope. A lambda begins with the capture clause (`[]`), which specifies which variables are captured, and whether the capture is by value or by reference. Variables that have the ampersand (`&`) prefix are accessed by reference and variables that do not have it are accessed by value.

We can use the default capture mode to indicate how to capture any outside variables that are referenced in the lambda: `[&]` means all variables that we refer to are captured by reference, and `[=]` means they are captured by value. We can even mix captures:

```cpp
[&total, factor] // total by reference, factor by value
[factor, &total] // same as before
[&, factor] //factor by value, everything else by reference (only variables the lambda actually accesses)
[factor, &] // same as before
[=, &total] //total by reference, everything else by value (only variables the lambda actually accesses)
[&total, =] // same as before
[&, this] // methods and data members of the enclosing class (this) and other variables by reference
[*this] // the enclosing class is copied into the lambda (the closure becomes self-contained)
```

In addition, from C++14 we can even introduce and initialize new variables in the capture clause, without the need to have those variables exist in the lambda functionâ€™s enclosing scope:

```cpp
pNums = make_unique<vector<int>>(nums);  
//...  
auto a = [ptr = move(pNums)]() {  
   // the lambda owns ptr
};  
```

### Return type

The return type of a lambda expression is automatically deduced:

```cpp
auto x1 = [](int i){ return i; }; // return type is int
```

Lambda return type deduction is the same as [auto return type deduction](http://en.cppreference.com/w/cpp/language/function#Return_type_deduction) that follows the rules of [template argument deduction](http://en.cppreference.com/w/cpp/language/template_argument_deduction#Other_contexts).

In other words, assume lambdas return by value and when we need to return differently we could specify what to return by hand:

```cpp
vector<int> v = {1,2,3};
auto get0    = [&]           { return v[0]; }; // return type is int
auto get0Ref = [&]() -> int& { return v[0]; }; // return type is int&
```

Such syntax is called **trailing return type**.

### How to hold and pass lambdas around?

 Because each lambda function is implemented by creating a separate class, as we saw earlier, **even single lambda function is really a different type** - even if the two functions have the same arguments and the same return value! 
 
 To store and pass lambdas around we have a few options supported by the standard:
 
 **`auto` and Templates**
 
 `auto` is always our friend when we need to declare variables whose type we don't know:
 
 ```cpp
 auto lam = [](int i, int j) { return i+j; };
 ```
 
This is the most efficient way to store lambdas. Similarly, we can pass lambdas by using templates:

```cpp
template<typename Callable>
void MyAlgo(Callable callable);

MyAlgo(lam);
```

Sometimes we have to commit to a non-generic type, for different reasons. 
 
 **Function pointers**
 
 Committing stateless lambdas to function pointers is automatic:
 
 ```cpp
 using FunPtr = void(*)(int, int);
 
 void MyAlgo(FunPtr);
 
 auto lam = [](int i, int j) { ... };
 MyAlgo(lam); // automatic conversion
 ```
 
 What about stateful lambdas?
 
 `std::function`
 
 C++11 introduces a convenient wrapper for storing any kind of function (lambda function, functor, or function pointer)


Continue Reading:

* Up to C++11 but a very good start: [Lambda Functions in C++11 - the Definitive Guide](https://www.cprogramming.com/c++11/c++11-lambda-closures.html)
* [Microsoft on Lambda Expressions in C++](https://docs.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp)
* [Examples of Lambda Expressions](https://docs.microsoft.com/en-us/cpp/cpp/examples-of-lambda-expressions)
* Arne Mertz: [Part 1](https://arne-mertz.de/2015/10/new-c-features-lambdas/) and [Part 2](https://arne-mertz.de/2015/11/lambdas-part-2-capture-lists-and-stateful-closures/)

## Hands on!

@[Implement a visit function in our service]({"stubs": [ 
	 "microurl/src/ver6/MicroUrlService.h",
	 "microurl/src/ver6/tests/VisitTest.cpp",
	],
	"command": "sh /project/target/run_test.sh ver6 [visit]"})

## Bonus: passing stateful visitors

The functional touch you have added to our service has impressed many developers. One guy implemented a visitor to find the most popular url that our users feed MicroUrl with. Although the logic seems correct, the test he wrote is not passing.

Can you help him?

@[Fix the test]({"stubs": [ 
	 "microurl/src/ver6/MicroUrlService.h",
	 "microurl/src/ver6/tests/StatefulVisitTest.cpp",
	],
	"command": "sh /project/target/run_test.sh ver6 [stateful]"})
	
::: Do you really give up? :(

Range-based for loop combined with structure bindings (what a pity, we cannot express that `id` is unused)...

```cpp
template<typename Action>
void MicroUrlService::VisitMicroUrls(Action action) const
{
	for (auto&[id, url] : m_idToUrl)
		action(url);
}
```
:::